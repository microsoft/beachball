import{c as _}from"./chunk-4KE642ED-BeG2C4YJ.js";import{s as U}from"./chunk-VSLJSFIP-BnVCLdBh.js";import{p as Y}from"./treemap-KMMF4GRG-DK74C3S3-CzpnMqvo.js";import{m as d,d as J,J as Q,K as V,Q as X,Z,j as tt,t as u,h as et,k as rt,U as at,u as it,X as nt,b as E,L as ot,O as st,I as ct,w as ht}from"./mermaid.esm.min-D65HMj23.js";import"./chunk-5ZJXQJOJ-BXFEBTr6.js";import"./app-B4ncHSV0.js";var f={NORMAL:0,REVERSE:1,HIGHLIGHT:2,MERGE:3,CHERRY_PICK:4},dt=ct.gitGraph,P=d(()=>ot({...dt,...st().gitGraph}),"getConfig"),c=new U(()=>{let e=P(),t=e.mainBranchName,i=e.mainBranchOrder;return{mainBranchName:t,commits:new Map,head:null,branchConfig:new Map([[t,{name:t,order:i}]]),branches:new Map([[t,null]]),currBranch:t,direction:"LR",seq:0,options:{}}});function O(){return ht({length:7})}d(O,"getID");function D(e,t){let i=Object.create(null);return e.reduce((n,r)=>{let a=t(r);return i[a]||(i[a]=!0,n.push(r)),n},[])}d(D,"uniqBy");var mt=d(function(e){c.records.direction=e},"setDirection"),lt=d(function(e){u.debug("options str",e),e=e?.trim(),e=e||"{}";try{c.records.options=JSON.parse(e)}catch(t){u.error("error while parsing gitGraph options",t.message)}},"setOptions"),$t=d(function(){return c.records.options},"getOptions"),gt=d(function(e){let t=e.msg,i=e.id,n=e.type,r=e.tags;u.info("commit",t,i,n,r),u.debug("Entering commit:",t,i,n,r);let a=P();i=E.sanitizeText(i,a),t=E.sanitizeText(t,a),r=r?.map(o=>E.sanitizeText(o,a));let h={id:i||c.records.seq+"-"+O(),message:t,seq:c.records.seq++,type:n??f.NORMAL,tags:r??[],parents:c.records.head==null?[]:[c.records.head.id],branch:c.records.currBranch};c.records.head=h,u.info("main branch",a.mainBranchName),c.records.commits.has(h.id)&&u.warn(`Commit ID ${h.id} already exists`),c.records.commits.set(h.id,h),c.records.branches.set(c.records.currBranch,h.id),u.debug("in pushCommit "+h.id)},"commit"),yt=d(function(e){let t=e.name,i=e.order;if(t=E.sanitizeText(t,P()),c.records.branches.has(t))throw new Error(`Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ${t}")`);c.records.branches.set(t,c.records.head!=null?c.records.head.id:null),c.records.branchConfig.set(t,{name:t,order:i}),j(t),u.debug("in createBranch")},"branch"),pt=d(e=>{let t=e.branch,i=e.id,n=e.type,r=e.tags,a=P();t=E.sanitizeText(t,a),i&&(i=E.sanitizeText(i,a));let h=c.records.branches.get(c.records.currBranch),o=c.records.branches.get(t),$=h?c.records.commits.get(h):void 0,m=o?c.records.commits.get(o):void 0;if($&&m&&$.branch===t)throw new Error(`Cannot merge branch '${t}' into itself.`);if(c.records.currBranch===t){let s=new Error('Incorrect usage of "merge". Cannot merge a branch to itself');throw s.hash={text:`merge ${t}`,token:`merge ${t}`,expected:["branch abc"]},s}if($===void 0||!$){let s=new Error(`Incorrect usage of "merge". Current branch (${c.records.currBranch})has no commits`);throw s.hash={text:`merge ${t}`,token:`merge ${t}`,expected:["commit"]},s}if(!c.records.branches.has(t)){let s=new Error('Incorrect usage of "merge". Branch to be merged ('+t+") does not exist");throw s.hash={text:`merge ${t}`,token:`merge ${t}`,expected:[`branch ${t}`]},s}if(m===void 0||!m){let s=new Error('Incorrect usage of "merge". Branch to be merged ('+t+") has no commits");throw s.hash={text:`merge ${t}`,token:`merge ${t}`,expected:['"commit"']},s}if($===m){let s=new Error('Incorrect usage of "merge". Both branches have same head');throw s.hash={text:`merge ${t}`,token:`merge ${t}`,expected:["branch abc"]},s}if(i&&c.records.commits.has(i)){let s=new Error('Incorrect usage of "merge". Commit with id:'+i+" already exists, use different custom id");throw s.hash={text:`merge ${t} ${i} ${n} ${r?.join(" ")}`,token:`merge ${t} ${i} ${n} ${r?.join(" ")}`,expected:[`merge ${t} ${i}_UNIQUE ${n} ${r?.join(" ")}`]},s}let l=o||"",g={id:i||`${c.records.seq}-${O()}`,message:`merged branch ${t} into ${c.records.currBranch}`,seq:c.records.seq++,parents:c.records.head==null?[]:[c.records.head.id,l],branch:c.records.currBranch,type:f.MERGE,customType:n,customId:!!i,tags:r??[]};c.records.head=g,c.records.commits.set(g.id,g),c.records.branches.set(c.records.currBranch,g.id),u.debug(c.records.branches),u.debug("in mergeBranch")},"merge"),ft=d(function(e){let t=e.id,i=e.targetId,n=e.tags,r=e.parent;u.debug("Entering cherryPick:",t,i,n);let a=P();if(t=E.sanitizeText(t,a),i=E.sanitizeText(i,a),n=n?.map($=>E.sanitizeText($,a)),r=E.sanitizeText(r,a),!t||!c.records.commits.has(t)){let $=new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided');throw $.hash={text:`cherryPick ${t} ${i}`,token:`cherryPick ${t} ${i}`,expected:["cherry-pick abc"]},$}let h=c.records.commits.get(t);if(h===void 0||!h)throw new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided');if(r&&!(Array.isArray(h.parents)&&h.parents.includes(r)))throw new Error("Invalid operation: The specified parent commit is not an immediate parent of the cherry-picked commit.");let o=h.branch;if(h.type===f.MERGE&&!r)throw new Error("Incorrect usage of cherry-pick: If the source commit is a merge commit, an immediate parent commit must be specified.");if(!i||!c.records.commits.has(i)){if(o===c.records.currBranch){let g=new Error('Incorrect usage of "cherryPick". Source commit is already on current branch');throw g.hash={text:`cherryPick ${t} ${i}`,token:`cherryPick ${t} ${i}`,expected:["cherry-pick abc"]},g}let $=c.records.branches.get(c.records.currBranch);if($===void 0||!$){let g=new Error(`Incorrect usage of "cherry-pick". Current branch (${c.records.currBranch})has no commits`);throw g.hash={text:`cherryPick ${t} ${i}`,token:`cherryPick ${t} ${i}`,expected:["cherry-pick abc"]},g}let m=c.records.commits.get($);if(m===void 0||!m){let g=new Error(`Incorrect usage of "cherry-pick". Current branch (${c.records.currBranch})has no commits`);throw g.hash={text:`cherryPick ${t} ${i}`,token:`cherryPick ${t} ${i}`,expected:["cherry-pick abc"]},g}let l={id:c.records.seq+"-"+O(),message:`cherry-picked ${h?.message} into ${c.records.currBranch}`,seq:c.records.seq++,parents:c.records.head==null?[]:[c.records.head.id,h.id],branch:c.records.currBranch,type:f.CHERRY_PICK,tags:n?n.filter(Boolean):[`cherry-pick:${h.id}${h.type===f.MERGE?`|parent:${r}`:""}`]};c.records.head=l,c.records.commits.set(l.id,l),c.records.branches.set(c.records.currBranch,l.id),u.debug(c.records.branches),u.debug("in cherryPick")}},"cherryPick"),j=d(function(e){if(e=E.sanitizeText(e,P()),c.records.branches.has(e)){c.records.currBranch=e;let t=c.records.branches.get(c.records.currBranch);t===void 0||!t?c.records.head=null:c.records.head=c.records.commits.get(t)??null}else{let t=new Error(`Trying to checkout branch which is not yet created. (Help try using "branch ${e}")`);throw t.hash={text:`checkout ${e}`,token:`checkout ${e}`,expected:[`branch ${e}`]},t}},"checkout");function H(e,t,i){let n=e.indexOf(t);n===-1?e.push(i):e.splice(n,1,i)}d(H,"upsert");function z(e){let t=e.reduce((r,a)=>r.seq>a.seq?r:a,e[0]),i="";e.forEach(function(r){r===t?i+="	*":i+="	|"});let n=[i,t.id,t.seq];for(let r in c.records.branches)c.records.branches.get(r)===t.id&&n.push(r);if(u.debug(n.join(" ")),t.parents&&t.parents.length==2&&t.parents[0]&&t.parents[1]){let r=c.records.commits.get(t.parents[0]);H(e,t,r),t.parents[1]&&e.push(c.records.commits.get(t.parents[1]))}else{if(t.parents.length==0)return;if(t.parents[0]){let r=c.records.commits.get(t.parents[0]);H(e,t,r)}}e=D(e,r=>r.id),z(e)}d(z,"prettyPrintCommitHistory");var xt=d(function(){u.debug(c.records.commits);let e=N()[0];z([e])},"prettyPrint"),ut=d(function(){c.reset(),nt()},"clear"),bt=d(function(){return[...c.records.branchConfig.values()].map((e,t)=>e.order!==null&&e.order!==void 0?e:{...e,order:parseFloat(`0.${t}`)}).sort((e,t)=>(e.order??0)-(t.order??0)).map(({name:e})=>({name:e}))},"getBranchesAsObjArray"),wt=d(function(){return c.records.branches},"getBranches"),Bt=d(function(){return c.records.commits},"getCommits"),N=d(function(){let e=[...c.records.commits.values()];return e.forEach(function(t){u.debug(t.id)}),e.sort((t,i)=>t.seq-i.seq),e},"getCommitsArray"),Et=d(function(){return c.records.currBranch},"getCurrentBranch"),kt=d(function(){return c.records.direction},"getDirection"),Ct=d(function(){return c.records.head},"getHead"),W={commitType:f,getConfig:P,setDirection:mt,setOptions:lt,getOptions:$t,commit:gt,branch:yt,merge:pt,cherryPick:ft,checkout:j,prettyPrint:xt,clear:ut,getBranchesAsObjArray:bt,getBranches:wt,getCommits:Bt,getCommitsArray:N,getCurrentBranch:Et,getDirection:kt,getHead:Ct,setAccTitle:tt,getAccTitle:Z,getAccDescription:X,setAccDescription:V,setDiagramTitle:Q,getDiagramTitle:J},Lt=d((e,t)=>{_(e,t),e.dir&&t.setDirection(e.dir);for(let i of e.statements)Tt(i,t)},"populate"),Tt=d((e,t)=>{let i={Commit:d(n=>t.commit(Mt(n)),"Commit"),Branch:d(n=>t.branch(vt(n)),"Branch"),Merge:d(n=>t.merge(Pt(n)),"Merge"),Checkout:d(n=>t.checkout(Rt(n)),"Checkout"),CherryPicking:d(n=>t.cherryPick(It(n)),"CherryPicking")}[e.$type];i?i(e):u.error(`Unknown statement type: ${e.$type}`)},"parseStatement"),Mt=d(e=>({id:e.id,msg:e.message??"",type:e.type!==void 0?f[e.type]:f.NORMAL,tags:e.tags??void 0}),"parseCommit"),vt=d(e=>({name:e.name,order:e.order??0}),"parseBranch"),Pt=d(e=>({branch:e.branch,id:e.id??"",type:e.type!==void 0?f[e.type]:void 0,tags:e.tags??void 0}),"parseMerge"),Rt=d(e=>e.branch,"parseCheckout"),It=d(e=>({id:e.id,targetId:"",tags:e.tags?.length===0?void 0:e.tags,parent:e.parent}),"parseCherryPicking"),At={parse:d(async e=>{let t=await Y("gitGraph",e);u.debug(t),Lt(t,W)},"parse")},Gt=et(),B=Gt?.gitGraph,T=10,M=40,k=4,C=2,v=8,b=new Map,w=new Map,A=30,R=new Map,G=[],L=0,y="LR",Ot=d(()=>{b.clear(),w.clear(),R.clear(),L=0,G=[],y="LR"},"clear"),K=d(e=>{let t=document.createElementNS("http://www.w3.org/2000/svg","text");return(typeof e=="string"?e.split(/\\n|\n|<br\s*\/?>/gi):e).forEach(i=>{let n=document.createElementNS("http://www.w3.org/2000/svg","tspan");n.setAttributeNS("http://www.w3.org/XML/1998/namespace","xml:space","preserve"),n.setAttribute("dy","1em"),n.setAttribute("x","0"),n.setAttribute("class","row"),n.textContent=i.trim(),t.appendChild(n)}),t},"drawText"),F=d(e=>{let t,i,n;return y==="BT"?(i=d((r,a)=>r<=a,"comparisonFunc"),n=1/0):(i=d((r,a)=>r>=a,"comparisonFunc"),n=0),e.forEach(r=>{let a=y==="TB"||y=="BT"?w.get(r)?.y:w.get(r)?.x;a!==void 0&&i(a,n)&&(t=r,n=a)}),t},"findClosestParent"),qt=d(e=>{let t="",i=1/0;return e.forEach(n=>{let r=w.get(n).y;r<=i&&(t=n,i=r)}),t||void 0},"findClosestParentBT"),Ht=d((e,t,i)=>{let n=i,r=i,a=[];e.forEach(h=>{let o=t.get(h);if(!o)throw new Error(`Commit not found for key ${h}`);o.parents.length?(n=St(o),r=Math.max(n,r)):a.push(o),Dt(o,n)}),n=r,a.forEach(h=>{jt(h,n,i)}),e.forEach(h=>{let o=t.get(h);if(o?.parents.length){let $=qt(o.parents);n=w.get($).y-M,n<=r&&(r=n);let m=b.get(o.branch).pos,l=n-T;w.set(o.id,{x:m,y:l})}})},"setParallelBTPos"),zt=d(e=>{let t=F(e.parents.filter(n=>n!==null));if(!t)throw new Error(`Closest parent not found for commit ${e.id}`);let i=w.get(t)?.y;if(i===void 0)throw new Error(`Closest parent position not found for commit ${e.id}`);return i},"findClosestParentPos"),St=d(e=>zt(e)+M,"calculateCommitPosition"),Dt=d((e,t)=>{let i=b.get(e.branch);if(!i)throw new Error(`Branch not found for commit ${e.id}`);let n=i.pos,r=t+T;return w.set(e.id,{x:n,y:r}),{x:n,y:r}},"setCommitPosition"),jt=d((e,t,i)=>{let n=b.get(e.branch);if(!n)throw new Error(`Branch not found for commit ${e.id}`);let r=t+i,a=n.pos;w.set(e.id,{x:a,y:r})},"setRootPosition"),Nt=d((e,t,i,n,r,a)=>{if(a===f.HIGHLIGHT)e.append("rect").attr("x",i.x-10).attr("y",i.y-10).attr("width",20).attr("height",20).attr("class",`commit ${t.id} commit-highlight${r%v} ${n}-outer`),e.append("rect").attr("x",i.x-6).attr("y",i.y-6).attr("width",12).attr("height",12).attr("class",`commit ${t.id} commit${r%v} ${n}-inner`);else if(a===f.CHERRY_PICK)e.append("circle").attr("cx",i.x).attr("cy",i.y).attr("r",10).attr("class",`commit ${t.id} ${n}`),e.append("circle").attr("cx",i.x-3).attr("cy",i.y+2).attr("r",2.75).attr("fill","#fff").attr("class",`commit ${t.id} ${n}`),e.append("circle").attr("cx",i.x+3).attr("cy",i.y+2).attr("r",2.75).attr("fill","#fff").attr("class",`commit ${t.id} ${n}`),e.append("line").attr("x1",i.x+3).attr("y1",i.y+1).attr("x2",i.x).attr("y2",i.y-5).attr("stroke","#fff").attr("class",`commit ${t.id} ${n}`),e.append("line").attr("x1",i.x-3).attr("y1",i.y+1).attr("x2",i.x).attr("y2",i.y-5).attr("stroke","#fff").attr("class",`commit ${t.id} ${n}`);else{let h=e.append("circle");if(h.attr("cx",i.x),h.attr("cy",i.y),h.attr("r",t.type===f.MERGE?9:10),h.attr("class",`commit ${t.id} commit${r%v}`),a===f.MERGE){let o=e.append("circle");o.attr("cx",i.x),o.attr("cy",i.y),o.attr("r",6),o.attr("class",`commit ${n} ${t.id} commit${r%v}`)}a===f.REVERSE&&e.append("path").attr("d",`M ${i.x-5},${i.y-5}L${i.x+5},${i.y+5}M${i.x-5},${i.y+5}L${i.x+5},${i.y-5}`).attr("class",`commit ${n} ${t.id} commit${r%v}`)}},"drawCommitBullet"),Wt=d((e,t,i,n)=>{if(t.type!==f.CHERRY_PICK&&(t.customId&&t.type===f.MERGE||t.type!==f.MERGE)&&B?.showCommitLabel){let r=e.append("g"),a=r.insert("rect").attr("class","commit-label-bkg"),h=r.append("text").attr("x",n).attr("y",i.y+25).attr("class","commit-label").text(t.id),o=h.node()?.getBBox();if(o&&(a.attr("x",i.posWithOffset-o.width/2-C).attr("y",i.y+13.5).attr("width",o.width+2*C).attr("height",o.height+2*C),y==="TB"||y==="BT"?(a.attr("x",i.x-(o.width+4*k+5)).attr("y",i.y-12),h.attr("x",i.x-(o.width+4*k)).attr("y",i.y+o.height-12)):h.attr("x",i.posWithOffset-o.width/2),B.rotateCommitLabel))if(y==="TB"||y==="BT")h.attr("transform","rotate(-45, "+i.x+", "+i.y+")"),a.attr("transform","rotate(-45, "+i.x+", "+i.y+")");else{let $=-7.5-(o.width+10)/25*9.5,m=10+o.width/25*8.5;r.attr("transform","translate("+$+", "+m+") rotate(-45, "+n+", "+i.y+")")}}},"drawCommitLabel"),Kt=d((e,t,i,n)=>{if(t.tags.length>0){let r=0,a=0,h=0,o=[];for(let $ of t.tags.reverse()){let m=e.insert("polygon"),l=e.append("circle"),g=e.append("text").attr("y",i.y-16-r).attr("class","tag-label").text($),s=g.node()?.getBBox();if(!s)throw new Error("Tag bbox not found");a=Math.max(a,s.width),h=Math.max(h,s.height),g.attr("x",i.posWithOffset-s.width/2),o.push({tag:g,hole:l,rect:m,yOffset:r}),r+=20}for(let{tag:$,hole:m,rect:l,yOffset:g}of o){let s=h/2,x=i.y-19.2-g;if(l.attr("class","tag-label-bkg").attr("points",`
      ${n-a/2-k/2},${x+C}  
      ${n-a/2-k/2},${x-C}
      ${i.posWithOffset-a/2-k},${x-s-C}
      ${i.posWithOffset+a/2+k},${x-s-C}
      ${i.posWithOffset+a/2+k},${x+s+C}
      ${i.posWithOffset-a/2-k},${x+s+C}`),m.attr("cy",x).attr("cx",n-a/2+k/2).attr("r",1.5).attr("class","tag-hole"),y==="TB"||y==="BT"){let p=n+g;l.attr("class","tag-label-bkg").attr("points",`
        ${i.x},${p+2}
        ${i.x},${p-2}
        ${i.x+T},${p-s-2}
        ${i.x+T+a+4},${p-s-2}
        ${i.x+T+a+4},${p+s+2}
        ${i.x+T},${p+s+2}`).attr("transform","translate(12,12) rotate(45, "+i.x+","+n+")"),m.attr("cx",i.x+k/2).attr("cy",p).attr("transform","translate(12,12) rotate(45, "+i.x+","+n+")"),$.attr("x",i.x+5).attr("y",p+3).attr("transform","translate(14,14) rotate(45, "+i.x+","+n+")")}}}},"drawCommitTags"),Ft=d(e=>{switch(e.customType??e.type){case f.NORMAL:return"commit-normal";case f.REVERSE:return"commit-reverse";case f.HIGHLIGHT:return"commit-highlight";case f.MERGE:return"commit-merge";case f.CHERRY_PICK:return"commit-cherry-pick";default:return"commit-normal"}},"getCommitClassType"),_t=d((e,t,i,n)=>{let r={x:0,y:0};if(e.parents.length>0){let a=F(e.parents);if(a){let h=n.get(a)??r;return t==="TB"?h.y+M:t==="BT"?(n.get(e.id)??r).y-M:h.x+M}}else return t==="TB"?A:t==="BT"?(n.get(e.id)??r).y-M:0;return 0},"calculatePosition"),Ut=d((e,t,i)=>{let n=y==="BT"&&i?t:t+T,r=y==="TB"||y==="BT"?n:b.get(e.branch)?.pos,a=y==="TB"||y==="BT"?b.get(e.branch)?.pos:n;if(a===void 0||r===void 0)throw new Error(`Position were undefined for commit ${e.id}`);return{x:a,y:r,posWithOffset:n}},"getCommitPosition"),S=d((e,t,i)=>{if(!B)throw new Error("GitGraph config not found");let n=e.append("g").attr("class","commit-bullets"),r=e.append("g").attr("class","commit-labels"),a=y==="TB"||y==="BT"?A:0,h=[...t.keys()],o=B?.parallelCommits??!1,$=d((l,g)=>{let s=t.get(l)?.seq,x=t.get(g)?.seq;return s!==void 0&&x!==void 0?s-x:0},"sortKeys"),m=h.sort($);y==="BT"&&(o&&Ht(m,t,a),m=m.reverse()),m.forEach(l=>{let g=t.get(l);if(!g)throw new Error(`Commit not found for key ${l}`);o&&(a=_t(g,y,a,w));let s=Ut(g,a,o);if(i){let x=Ft(g),p=g.customType??g.type,q=b.get(g.branch)?.index??0;Nt(n,g,s,x,q,p),Wt(r,g,s,a),Kt(r,g,s,a)}y==="TB"||y==="BT"?w.set(g.id,{x:s.x,y:s.posWithOffset}):w.set(g.id,{x:s.posWithOffset,y:s.y}),a=y==="BT"&&o?a+M:a+M+T,a>L&&(L=a)})},"drawCommits"),Yt=d((e,t,i,n,r)=>{let a=(y==="TB"||y==="BT"?i.x<n.x:i.y<n.y)?t.branch:e.branch,h=d($=>$.branch===a,"isOnBranchToGetCurve"),o=d($=>$.seq>e.seq&&$.seq<t.seq,"isBetweenCommits");return[...r.values()].some($=>o($)&&h($))},"shouldRerouteArrow"),I=d((e,t,i=0)=>{let n=e+Math.abs(e-t)/2;if(i>5)return n;if(G.every(a=>Math.abs(a-n)>=10))return G.push(n),n;let r=Math.abs(e-t);return I(e,t-r/5,i+1)},"findLane"),Jt=d((e,t,i,n)=>{let r=w.get(t.id),a=w.get(i.id);if(r===void 0||a===void 0)throw new Error(`Commit positions not found for commits ${t.id} and ${i.id}`);let h=Yt(t,i,r,a,n),o="",$="",m=0,l=0,g=b.get(i.branch)?.index;i.type===f.MERGE&&t.id!==i.parents[0]&&(g=b.get(t.branch)?.index);let s;if(h){o="A 10 10, 0, 0, 0,",$="A 10 10, 0, 0, 1,",m=10,l=10;let x=r.y<a.y?I(r.y,a.y):I(a.y,r.y),p=r.x<a.x?I(r.x,a.x):I(a.x,r.x);y==="TB"?r.x<a.x?s=`M ${r.x} ${r.y} L ${p-m} ${r.y} ${$} ${p} ${r.y+l} L ${p} ${a.y-m} ${o} ${p+l} ${a.y} L ${a.x} ${a.y}`:(g=b.get(t.branch)?.index,s=`M ${r.x} ${r.y} L ${p+m} ${r.y} ${o} ${p} ${r.y+l} L ${p} ${a.y-m} ${$} ${p-l} ${a.y} L ${a.x} ${a.y}`):y==="BT"?r.x<a.x?s=`M ${r.x} ${r.y} L ${p-m} ${r.y} ${o} ${p} ${r.y-l} L ${p} ${a.y+m} ${$} ${p+l} ${a.y} L ${a.x} ${a.y}`:(g=b.get(t.branch)?.index,s=`M ${r.x} ${r.y} L ${p+m} ${r.y} ${$} ${p} ${r.y-l} L ${p} ${a.y+m} ${o} ${p-l} ${a.y} L ${a.x} ${a.y}`):r.y<a.y?s=`M ${r.x} ${r.y} L ${r.x} ${x-m} ${o} ${r.x+l} ${x} L ${a.x-m} ${x} ${$} ${a.x} ${x+l} L ${a.x} ${a.y}`:(g=b.get(t.branch)?.index,s=`M ${r.x} ${r.y} L ${r.x} ${x+m} ${$} ${r.x+l} ${x} L ${a.x-m} ${x} ${o} ${a.x} ${x-l} L ${a.x} ${a.y}`)}else o="A 20 20, 0, 0, 0,",$="A 20 20, 0, 0, 1,",m=20,l=20,y==="TB"?(r.x<a.x&&(i.type===f.MERGE&&t.id!==i.parents[0]?s=`M ${r.x} ${r.y} L ${r.x} ${a.y-m} ${o} ${r.x+l} ${a.y} L ${a.x} ${a.y}`:s=`M ${r.x} ${r.y} L ${a.x-m} ${r.y} ${$} ${a.x} ${r.y+l} L ${a.x} ${a.y}`),r.x>a.x&&(o="A 20 20, 0, 0, 0,",$="A 20 20, 0, 0, 1,",m=20,l=20,i.type===f.MERGE&&t.id!==i.parents[0]?s=`M ${r.x} ${r.y} L ${r.x} ${a.y-m} ${$} ${r.x-l} ${a.y} L ${a.x} ${a.y}`:s=`M ${r.x} ${r.y} L ${a.x+m} ${r.y} ${o} ${a.x} ${r.y+l} L ${a.x} ${a.y}`),r.x===a.x&&(s=`M ${r.x} ${r.y} L ${a.x} ${a.y}`)):y==="BT"?(r.x<a.x&&(i.type===f.MERGE&&t.id!==i.parents[0]?s=`M ${r.x} ${r.y} L ${r.x} ${a.y+m} ${$} ${r.x+l} ${a.y} L ${a.x} ${a.y}`:s=`M ${r.x} ${r.y} L ${a.x-m} ${r.y} ${o} ${a.x} ${r.y-l} L ${a.x} ${a.y}`),r.x>a.x&&(o="A 20 20, 0, 0, 0,",$="A 20 20, 0, 0, 1,",m=20,l=20,i.type===f.MERGE&&t.id!==i.parents[0]?s=`M ${r.x} ${r.y} L ${r.x} ${a.y+m} ${o} ${r.x-l} ${a.y} L ${a.x} ${a.y}`:s=`M ${r.x} ${r.y} L ${a.x-m} ${r.y} ${o} ${a.x} ${r.y-l} L ${a.x} ${a.y}`),r.x===a.x&&(s=`M ${r.x} ${r.y} L ${a.x} ${a.y}`)):(r.y<a.y&&(i.type===f.MERGE&&t.id!==i.parents[0]?s=`M ${r.x} ${r.y} L ${a.x-m} ${r.y} ${$} ${a.x} ${r.y+l} L ${a.x} ${a.y}`:s=`M ${r.x} ${r.y} L ${r.x} ${a.y-m} ${o} ${r.x+l} ${a.y} L ${a.x} ${a.y}`),r.y>a.y&&(i.type===f.MERGE&&t.id!==i.parents[0]?s=`M ${r.x} ${r.y} L ${a.x-m} ${r.y} ${o} ${a.x} ${r.y-l} L ${a.x} ${a.y}`:s=`M ${r.x} ${r.y} L ${r.x} ${a.y+m} ${$} ${r.x+l} ${a.y} L ${a.x} ${a.y}`),r.y===a.y&&(s=`M ${r.x} ${r.y} L ${a.x} ${a.y}`));if(s===void 0)throw new Error("Line definition not found");e.append("path").attr("d",s).attr("class","arrow arrow"+g%v)},"drawArrow"),Qt=d((e,t)=>{let i=e.append("g").attr("class","commit-arrows");[...t.keys()].forEach(n=>{let r=t.get(n);r.parents&&r.parents.length>0&&r.parents.forEach(a=>{Jt(i,t.get(a),r,t)})})},"drawArrows"),Vt=d((e,t)=>{let i=e.append("g");t.forEach((n,r)=>{let a=r%v,h=b.get(n.name)?.pos;if(h===void 0)throw new Error(`Position not found for branch ${n.name}`);let o=i.append("line");o.attr("x1",0),o.attr("y1",h),o.attr("x2",L),o.attr("y2",h),o.attr("class","branch branch"+a),y==="TB"?(o.attr("y1",A),o.attr("x1",h),o.attr("y2",L),o.attr("x2",h)):y==="BT"&&(o.attr("y1",L),o.attr("x1",h),o.attr("y2",A),o.attr("x2",h)),G.push(h);let $=n.name,m=K($),l=i.insert("rect"),g=i.insert("g").attr("class","branchLabel").insert("g").attr("class","label branch-label"+a);g.node().appendChild(m);let s=m.getBBox();l.attr("class","branchLabelBkg label"+a).attr("rx",4).attr("ry",4).attr("x",-s.width-4-(B?.rotateCommitLabel===!0?30:0)).attr("y",-s.height/2+8).attr("width",s.width+18).attr("height",s.height+4),g.attr("transform","translate("+(-s.width-14-(B?.rotateCommitLabel===!0?30:0))+", "+(h-s.height/2-1)+")"),y==="TB"?(l.attr("x",h-s.width/2-10).attr("y",0),g.attr("transform","translate("+(h-s.width/2-5)+", 0)")):y==="BT"?(l.attr("x",h-s.width/2-10).attr("y",L),g.attr("transform","translate("+(h-s.width/2-5)+", "+L+")")):l.attr("transform","translate(-19, "+(h-s.height/2)+")")})},"drawBranches"),Xt=d(function(e,t,i,n,r){return b.set(e,{pos:t,index:i}),t+=50+(r?40:0)+(y==="TB"||y==="BT"?n.width/2:0),t},"setBranchPosition"),Zt=d(function(e,t,i,n){if(Ot(),u.debug("in gitgraph renderer",e+`
`,"id:",t,i),!B)throw new Error("GitGraph config not found");let r=B.rotateCommitLabel??!1,a=n.db;R=a.getCommits();let h=a.getBranchesAsObjArray();y=a.getDirection();let o=rt(`[id="${t}"]`),$=0;h.forEach((m,l)=>{let g=K(m.name),s=o.append("g"),x=s.insert("g").attr("class","branchLabel"),p=x.insert("g").attr("class","label branch-label");p.node()?.appendChild(g);let q=g.getBBox();$=Xt(m.name,$,l,q,r),p.remove(),x.remove(),s.remove()}),S(o,R,!1),B.showBranches&&Vt(o,h),Qt(o,R),S(o,R,!0),at.insertTitle(o,"gitTitleText",B.titleTopMargin??0,a.getDiagramTitle()),it(void 0,o,B.diagramPadding,B.useMaxWidth)},"draw"),te={draw:Zt},ee=d(e=>`
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0,1,2,3,4,5,6,7].map(t=>`
        .branch-label${t} { fill: ${e["gitBranchLabel"+t]}; }
        .commit${t} { stroke: ${e["git"+t]}; fill: ${e["git"+t]}; }
        .commit-highlight${t} { stroke: ${e["gitInv"+t]}; fill: ${e["gitInv"+t]}; }
        .label${t}  { fill: ${e["git"+t]}; }
        .arrow${t} { stroke: ${e["git"+t]}; }
        `).join(`
`)}

  .branch {
    stroke-width: 1;
    stroke: ${e.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelColor};}
  .commit-label-bkg { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${e.tagLabelFontSize}; fill: ${e.tagLabelColor};}
  .tag-label-bkg { fill: ${e.tagLabelBackground}; stroke: ${e.tagLabelBorder}; }
  .tag-hole { fill: ${e.textColor}; }

  .commit-merge {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }
  .commit-reverse {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  .gitTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
`,"getStyles"),re=ee,he={parser:At,db:W,renderer:te,styles:re};export{he as diagram};
