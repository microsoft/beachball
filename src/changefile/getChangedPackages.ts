import fs from 'fs-extra';
import path from 'path';
import minimatch from 'minimatch';
import { ChangeFileInfo, ChangeInfoMultiple } from '../types/ChangeInfo';
import { getChangePath } from '../paths';
import { getChanges, getStagedChanges, git, fetchRemoteBranch, parseRemoteBranch } from 'workspace-tools';
import { getScopedPackages } from '../monorepo/getScopedPackages';
import { BeachballOptions } from '../types/BeachballOptions';
import { PackageInfos, PackageInfo } from '../types/PackageInfo';

function getMatchingPackageInfo(
  file: string,
  cwd: string,
  packageInfosByPath: { [packageAbsPath: string]: PackageInfo }
) {
  const absFile = path.join(cwd, file);
  let absDir = '';

  do {
    absDir = path.dirname(absDir || absFile);
    if (packageInfosByPath[absDir]) {
      return [absDir, packageInfosByPath[absDir]] as const;
    }
  } while (absDir !== cwd);

  return [undefined, undefined] as const;
}

/**
 * Gets all the changed package names, regardless of the change files
 */
function getAllChangedPackages(options: BeachballOptions, packageInfos: PackageInfos): string[] {
  const { branch, path: cwd, verbose } = options;

  const changes = [...(getChanges(branch, cwd) || []), ...(getStagedChanges(cwd) || [])];
  verbose && console.log(`Found ${changes.length} changed files in branch "${branch}" (before filtering)`);

  if (!changes.length) {
    return [];
  }

  const scopedPackages = getScopedPackages(options, packageInfos);

  // Always ignore the CHANGELOG file because that's generated by beachball
  const ignorePatterns = [...(options.ignorePatterns || []), 'CHANGELOG.md', 'CHANGELOG.json'];
  const includedPackages = new Set<string>();
  const packageInfosByPath: { [packageAbsPath: string]: PackageInfo } = {};
  for (const info of Object.values(packageInfos)) {
    packageInfosByPath[path.dirname(info.packageJsonPath)] = info;
  }

  // Discover package roots from modded files
  changes
    .filter(moddedFile => {
      const isIncluded = !ignorePatterns.some(pattern => minimatch(moddedFile, pattern, { matchBase: true }));
      !isIncluded && verbose && console.log(`  - ~~${moddedFile}~~ (ignored by pattern)`);
      return isIncluded;
    })
    .forEach(moddedFile => {
      const [packageDir, packageInfo] = getMatchingPackageInfo(moddedFile, cwd, packageInfosByPath);

      if (packageDir && packageInfo) {
        if (packageInfo.private) {
          verbose && console.log(`  - ~~${moddedFile}~~ (${packageInfo.name} is private)`);
        } else if (packageInfo.combinedOptions.shouldPublish === false) {
          verbose && console.log(`  - ~~${moddedFile}~~ (${packageInfo.name} has beachball.shouldPublish=false)`);
        } else if (!scopedPackages.includes(packageInfo.name)) {
          verbose && console.log(`  - ~~${moddedFile}~~ (${packageInfo.name} is out of scope)`);
        } else {
          includedPackages.add(packageInfo.name);
          verbose && console.log(`  - ${moddedFile}`);
        }
      } else {
        verbose && console.log(`  - ~~${moddedFile}~~ (no package found)`);
      }
    });

  return [...includedPackages];
}

/**
 * Gets all the changed packages, accounting for change files
 */
export function getChangedPackages(options: BeachballOptions, packageInfos: PackageInfos) {
  const { fetch, path: cwd, branch } = options;

  const changePath = getChangePath(cwd);

  if (fetch) {
    const { remote, remoteBranch } = parseRemoteBranch(branch);
    console.log(`fetching latest from remotes "${remote}/${remoteBranch}"`);
    fetchRemoteBranch(remote, remoteBranch, cwd);
  }

  const changedPackages = getAllChangedPackages(options, packageInfos);

  const changeFilesResult = git(
    ['diff', '--name-only', '--relative', '--no-renames', '--diff-filter=A', `${branch}...`],
    { cwd }
  );

  if (!changePath || !fs.existsSync(changePath) || !changeFilesResult.success) {
    return changedPackages;
  }

  const changes = changeFilesResult.stdout.split(/\n/);
  const changeFiles = changes.filter(name => path.dirname(name) === 'change');
  const changeFilePackageSet = new Set<string>();

  // Loop through the change files, building up a set of packages that we can skip
  changeFiles.forEach(file => {
    try {
      const changeInfo: ChangeFileInfo | ChangeInfoMultiple = fs.readJSONSync(file);

      if ('changes' in changeInfo) {
        for (const change of (changeInfo as ChangeInfoMultiple).changes) {
          changeFilePackageSet.add(change.packageName);
        }
      } else {
        changeFilePackageSet.add((changeInfo as ChangeFileInfo).packageName);
      }
    } catch (e) {
      console.warn(`Error reading or parsing change file ${file}: ${e}`);
    }
  });

  if (changeFilePackageSet.size > 0) {
    console.log(
      'Your local repository already has change files for these packages:' +
        [...changeFilePackageSet]
          .sort()
          .map(pkg => `\n  ${pkg}`)
          .join('')
    );
  }

  return changedPackages.filter(pkgName => !changeFilePackageSet.has(pkgName));
}
