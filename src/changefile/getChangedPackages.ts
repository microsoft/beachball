import fs from 'fs-extra';
import path from 'path';
import minimatch from 'minimatch';
import { ChangeFileInfo, ChangeInfoMultiple } from '../types/ChangeInfo';
import { getChangePath } from '../paths';
import { getChanges, getStagedChanges, git, fetchRemoteBranch, parseRemoteBranch } from 'workspace-tools';
import { getScopedPackages } from '../monorepo/getScopedPackages';
import { BeachballOptions } from '../types/BeachballOptions';
import { PackageInfos, PackageInfo } from '../types/PackageInfo';

function getMatchingPackageInfo(
  file: string,
  cwd: string,
  packageInfosByPath: { [packageAbsNormalizedPath: string]: PackageInfo }
) {
  // Normalize all the paths before comparing (the packageInfosByPath entries should also be normalized)
  // to ensure ensure that this doesn't break on Windows if any input paths have forward slashes
  cwd = path.normalize(cwd);
  const absFile = path.normalize(path.join(cwd, file));
  let absDir = '';

  do {
    absDir = path.dirname(absDir || absFile);
    if (packageInfosByPath[absDir]) {
      return packageInfosByPath[absDir];
    }
  } while (absDir !== cwd);

  return undefined;
}

/**
 * Gets all the changed package names, regardless of the change files
 */
function getAllChangedPackages(options: BeachballOptions, packageInfos: PackageInfos): string[] {
  const { branch, path: cwd, verbose } = options;

  const verboseLog = (msg: string) => verbose && console.log(msg);
  const logIgnored = (file: string, reason: string) => verboseLog(`  - ~~${file}~~ (${reason})`);
  const logIncluded = (file: string) => verboseLog(`  - ${file}`);

  const changes = [...(getChanges(branch, cwd) || []), ...(getStagedChanges(cwd) || [])];
  verboseLog(`Found ${changes.length} changed files in branch "${branch}" (before filtering)`);

  if (!changes.length) {
    return [];
  }

  // Filter out changed files which are ignored by ignorePatterns.
  // Also ignore the CHANGELOG files because they're generated by beachball.
  const ignorePatterns = [...(options.ignorePatterns || []), 'CHANGELOG.md', 'CHANGELOG.json'];
  const nonIgnoredChanges = changes.filter(moddedFile => {
    const ignorePattern = ignorePatterns.find(pattern => minimatch(moddedFile, pattern, { matchBase: true }));
    ignorePattern && logIgnored(moddedFile, `ignored by pattern "${ignorePattern}"`);
    return !ignorePattern;
  });
  if (!nonIgnoredChanges.length) {
    verboseLog('All files were ignored');
    return [];
  }

  // Determine which package each changed file came from (using packageInfos[x].packageJsonPath),
  // and whether that package is in scope and not private
  const includedPackages = new Set<string>();
  let fileCount = 0;
  const scopedPackages = getScopedPackages(options, packageInfos);
  const packageInfosByPath: { [packageAbsNormalizedPath: string]: PackageInfo } = {};
  for (const info of Object.values(packageInfos)) {
    packageInfosByPath[path.normalize(path.dirname(info.packageJsonPath))] = info;
  }
  for (const moddedFile of nonIgnoredChanges) {
    const packageInfo = getMatchingPackageInfo(moddedFile, cwd, packageInfosByPath);

    const omitReason = !packageInfo
      ? 'no corresponding package found'
      : packageInfo.private
      ? `${packageInfo.name} is private`
      : packageInfo.combinedOptions.shouldPublish === false
      ? `${packageInfo.name} has beachball.shouldPublish=false`
      : !scopedPackages.includes(packageInfo.name)
      ? `${packageInfo.name} is out of scope`
      : ''; // not ignored

    if (omitReason) {
      logIgnored(moddedFile, omitReason);
    } else {
      includedPackages.add(packageInfo!.name);
      fileCount++;
      logIncluded(moddedFile);
    }
  }

  verboseLog(`Found ${fileCount} files in ${includedPackages.size} packages that should be published`);

  return [...includedPackages];
}

/**
 * Gets all the changed packages, accounting for change files
 */
export function getChangedPackages(options: BeachballOptions, packageInfos: PackageInfos) {
  const { fetch, path: cwd, branch } = options;

  const changePath = getChangePath(cwd);

  if (fetch) {
    const { remote, remoteBranch } = parseRemoteBranch(branch);
    console.log(`fetching latest from remotes "${remote}/${remoteBranch}"`);
    fetchRemoteBranch(remote, remoteBranch, cwd);
  }

  const changedPackages = getAllChangedPackages(options, packageInfos);

  const changeFilesResult = git(
    ['diff', '--name-only', '--relative', '--no-renames', '--diff-filter=A', `${branch}...`],
    { cwd }
  );

  if (!fs.existsSync(changePath) || !changeFilesResult.success) {
    return changedPackages;
  }

  const changes = changeFilesResult.stdout.split(/\n/);
  const changeFiles = changes.filter(name => path.dirname(name) === 'change');
  const changeFilePackageSet = new Set<string>();

  // Loop through the change files, building up a set of packages that we can skip
  changeFiles.forEach(file => {
    try {
      const changeInfo: ChangeFileInfo | ChangeInfoMultiple = fs.readJSONSync(file);

      if ('changes' in changeInfo) {
        for (const change of (changeInfo as ChangeInfoMultiple).changes) {
          changeFilePackageSet.add(change.packageName);
        }
      } else {
        changeFilePackageSet.add((changeInfo as ChangeFileInfo).packageName);
      }
    } catch (e) {
      console.warn(`Error reading or parsing change file ${file}: ${e}`);
    }
  });

  if (changeFilePackageSet.size > 0) {
    console.log(
      'Your local repository already has change files for these packages:' +
        [...changeFilePackageSet]
          .sort()
          .map(pkg => `\n  ${pkg}`)
          .join('')
    );
  }

  return changedPackages.filter(pkgName => !changeFilePackageSet.has(pkgName));
}
